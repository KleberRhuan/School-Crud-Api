= MVP – Arquitetura de Autenticação Stateless
Kleber Rhuan <kleber__rhuan@hotmail.com>
v1.0, 14-Jun-2025
:toc: right
:source-highlighter: highlightjs
:encoding: UTF-8

== 1. Ajustes Rápidos

. *JTI no Access Token*
* Adicionar claim `jti` (UUID) gerada em `JwtTokenProvider`.
* Propagar nos logs e métricas como label `token_jti`.

. *Refresh Token de uso único*
* Campo `used` (boolean) na tabela `refresh_tokens`.
* No fluxo de refresh, marcar como usado e emitir novo par _access/refresh_.

. *Logs estruturados*
* Incluir `reason` nas revogações: `LOGOUT`, `COMPROMISED`, `ROTATED`.
* Usar `application-name`, `env`, `jti`, `userId` nos campos-chave.

. *Cabeçalhos de segurança SPA*
* `Permissions-Policy: camera=(), microphone=()`
* `Cross-Origin-Opener-Policy: same-origin`

== 2. Extensões *Could Have*

| Extensão | Benefício | Inserção na arquitetura |
|----------|-----------|-------------------------|
| OIDC Adapter | Login social ou corporativo | `infrastructure.security.oidc.OidcAdapter` implementa `TokenService` |
| MFA (FIDO2/WebAuthn) | Second factor sem SMS/OTP | Use case `EnrollSecondFactor`; tabela `webauthn_credentials` |
| DPoP (Token Binding) | Evita replay de JWT | Validação no `JwtAuthFilter` (`dpop` header) |
| Zero-Trust interno | Impede movimento lateral | Service Mesh (SPIFFE) em `infrastructure.mesh` |
| Rotação de chaves | Menor blast radius | `KeyRotationJob` + Vault/Secrets Manager |

== 3. Rollout Incremental

=== M0 – Preparação
* Ativar SCA (OWASP Dependency-Check) + SAST (Semgrep) na pipeline.
* Configurar Secrets Scanning no GitHub.

=== M1 – Core Auth MVP
* Deliverables: `JwtTokenProvider`, `JwtAuthFilter`, `AuthController`.
* Métricas básicas via Micrometer; logs estruturados.

=== M2 – Observabilidade
* OpenTelemetry tracing (`trace-id` ↔ `jti`).
* Dashboards de funil login → refresh → logout no Grafana.

=== M3 – Segurança Avançada
* Rate-limit adaptativo; brute-force detection.
* Redis Block-List (`token_jti` blacklist).

=== M4 – Extensões Prioritárias
* Escolher **UMA**: OIDC _ou_ MFA.
* Feature toggles `@ConditionalOnProperty`.

=== M5 – Rotação Automática de Chaves
* `KeyRotationJob` diário + migração de public keys (JWKS endpoint).

=== M6 – Hardening & Mesh
* mTLS interno (Istio / Linkerd) + SPIFFE SVID issuance.

=== M7 – Post-GA
* Post-mortem automation, chaos testing de flows de revogação.

== 4. Estrutura de Pacotes

[source,tree]
----
com.kleberrhuan.auth
├── application
│   ├── dto
│   │   └── LoginRequest.java
│   ├── event
│   │   ├── UserAuthenticated.java
│   │   └── TokenRevoked.java
│   └── usecase
│       ├── AuthenticateUserUseCase.java
│       └── RefreshTokenUseCase.java
├── domain
│   ├── model
│   │   ├── User.java
│   │   └── RefreshToken.java
│   └── repository
│       └── RefreshTokenRepository.java
├── infrastructure
│   ├── security
│   │   ├── JwtTokenProvider.java
│   │   ├── JwtAuthFilter.java
│   │   └── SecurityConfig.java
│   ├── observability
│   │   ├── MetricsConfig.java
│   │   └── StructuredLoggingConfig.java
│   ├── mesh              # opcional
│   └── oidc              # opcional
└── config
    └── ApplicationConfig.java
----

== 5. Esboço de Código

=== 5.1 JwtTokenProvider

[source,java]
----
@Component
public final class JwtTokenProvider {

    private final KeyPair keyPair;
    private final Duration accessTtl = Duration.ofMinutes(15);
    private final Duration refreshTtl = Duration.ofDays(7);

    public String generateAccessToken(User user) {
        Instant now = Instant.now();
        return Jwts.builder()
                   .setId(UUID.randomUUID().toString())       // jti
                   .setSubject(user.getId().toString())
                   .claim("roles", user.getRoles())
                   .setIssuedAt(Date.from(now))
                   .setExpiration(Date.from(now.plus(accessTtl)))
                   .signWith(keyPair.getPrivate(), SignatureAlgorithm.RS256)
                   .compact();
    }

    public String generateRefreshToken(User user, UUID series) {
        Instant now = Instant.now();
        return Jwts.builder()
                   .setId(series.toString())
                   .setSubject(user.getId().toString())
                   .setIssuedAt(Date.from(now))
                   .setExpiration(Date.from(now.plus(refreshTtl)))
                   .signWith(keyPair.getPrivate(), SignatureAlgorithm.RS256)
                   .compact();
    }

    public Jws<Claims> parse(String token) {
        return Jwts.parserBuilder()
                   .setSigningKey(keyPair.getPublic())
                   .build()
                   .parseClaimsJws(token);
    }
}
----

=== 5.2 JwtAuthFilter (simplificado)

[source,java]
----
public class JwtAuthFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest req,
                                    HttpServletResponse res,
                                    FilterChain chain)
                                    throws ServletException, IOException {

        String header = req.getHeader(HttpHeaders.AUTHORIZATION);
        if (header != null && header.startsWith("Bearer ")) {
            String jwt = header.substring(7);
            try {
                Jws<Claims> claims = tokenProvider.parse(jwt);
                String userId = claims.getBody().getSubject();
                String jti    = claims.getBody().getId();
                // add trace correlation
                MDC.put("token_jti", jti);

                Authentication auth =
                    new UsernamePasswordAuthenticationToken(userId, null, roles(claims));
                SecurityContextHolder.getContext().setAuthentication(auth);
            } catch (JwtException ex) {
                meter.counter("auth.jwt.invalid").increment();
            }
        }
        chain.doFilter(req, res);
    }
}
----

=== 5.3 RefreshTokenUseCase (uso único)

[source,java]
----
@Transactional
public Tokens refresh(String oldRefreshToken) {
    Jws<Claims> claims = tokenProvider.parse(oldRefreshToken);
    UUID series = UUID.fromString(claims.getBody().getId());

    RefreshToken stored = repository.findBySeries(series)
                                    .orElseThrow(TokenNotFound::new);
    if (stored.isUsed()) throw new ReplayAttack();
    stored.markUsed();

    User user = userRepo.getById(stored.getUserId());
    String newAccess  = tokenProvider.generateAccessToken(user);
    String newRefresh = tokenProvider.generateRefreshToken(user, UUID.randomUUID());
    repository.save(new RefreshToken(newRefresh));

    eventPublisher.publish(new TokenRevoked(series, Reason.ROTATED));
    return new Tokens(newAccess, newRefresh);
}
----

=== 5.4 KeyRotationJob

[source,java]
----
@Scheduled(cron = "0 0 3 * * *", zone = "UTC")
public void rotate() {
    KeyPair newPair = keyManager.generate();
    keyManager.publishToJwks(newPair.getPublic());
    keyManager.deprecateOldPrivateKeys();
    log.info("JWT key pair rotated");
}
----

== 6. Observabilidade

[source,yaml]
----
management:
  metrics:
    tags:
      application: ${spring.application.name}
      env: ${ENV}
  otlp:
    tracing:
      endpoint: http://otel-collector:4317
logging:
  pattern:
    console: '{"ts":"%d{ISO8601}","level":"%p","msg":"%m","logger":"%c","jti":"%X{token_jti}","trace":"%X{traceId}"}%n'
----

== 7. Mensageria (Opcional)

Event-outbox pattern: publique `UserAuthenticated`, `TokenRevoked`
em `domain.event`; persistência em tabela `outbox`; consumidor envia
para Kafka. Escalável e não impacta transação principal.

== 8. Checklist de Readiness

* [ ] Pipeline com SCA/SAST e dependabot.
* [ ] Rollup Grafana & alertas (login_failures > X/5 min).
* [ ] Redis block-list ativo em produção.
* [ ] Plano de rotação de chaves testado em staging.

